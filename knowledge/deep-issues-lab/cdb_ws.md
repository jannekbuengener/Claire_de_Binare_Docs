# cdb\_screener\_ws – Rolle und Setup im Gesamtsystem

## Überblick und Rolle im Gesamtsystem

Claire de Binare besteht aus mehreren Diensten mit klar getrennten Aufgabenbereichen. Der **WS-Screener** (cdb\_screener\_ws) spielt dabei die Rolle des **Marktdaten-Feeders**: Er stellt einen Live-Datenstrom der Kursdaten über WebSocket von der Kryptobörse MEXC bereit[\[1\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/ARCHITEKTUR.md#L5-L9). Konkret abonniert dieser Service Echtzeit-Marktdaten (1-Minuten-Kerzen) für alle relevanten Handelspaare und normalisiert sie zu einheitlichen *MarketData*\-Events[\[1\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/ARCHITEKTUR.md#L5-L9). Parallel dazu gibt es einen **REST-Screener** (cdb\_screener\_rest) als Backup, der die Top-Kursbeweger („Top-Mover“) über die MEXC-REST-API ermitteln kann[\[2\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L46-L54). Der REST-Screener dient als falls WebSocket-Daten ausfallen sollten und liefert periodisch die größten Gewinner und Verlierer; im aktuellen System ist er jedoch standardmäßig deaktiviert (❌) und nicht erforderlich, solange der WebSocket-Feed stabil läuft[\[3\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L16-L24)[\[2\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L46-L54).

Neben den Screenern gibt es weitere Kernkomponenten im System:

* **Signal-Engine** (signal\_engine, Port 8001\) – Generiert Handelssignale auf Basis der technischen Analyse der Marktdaten[\[4\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/ARCHITEKTUR.md#L6-L9) (z.B. Momentum, Volumen) und publiziert *Signal*\-Events.

* **Risk-Manager** (risk\_manager, Port 8002\) – Prüft eingehende Signale gegen Risikoregeln (Positionsgrößen, Exposition, Stop-Loss, etc.) und erzeugt daraus *Order*\-Events oder *Alert*\-Events[\[5\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/ARCHITEKTUR.md#L7-L9).

* **Execution-Service** (execution\_service, Port 8003\) – Nimmt vom Risikomanager freigegebene Orders entgegen und führt sie über die MEXC-API aus (für Tests aktuell ein Mock-Executor)[\[6\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L54-L62). Ergebnisse werden als *order\_result*\-Events zurückgemeldet.

* **Persistenz & Bus**: Eine PostgreSQL-Datenbank (cdb\_postgres, Port 5432\) speichert persistente Daten (z.B. Orders/Trades) und ein Redis-Server (cdb\_redis, Port 6379 intern, gemappt auf 6380 extern) fungiert als Message-Bus zur Event-Weiterleitung[\[7\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L50-L58). Redis ermöglicht die lose Kopplung der Komponenten über Pub/Sub-Kanäle.

**WS-Screener (cdb\_screener\_ws, Port 8000\)** ist somit die Daten-Eingangsschicht des Systems: Er streamt Kursinformationen in Echtzeit und publiziert sie über Redis an alle nachgelagerten Komponenten[\[2\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L46-L54)[\[7\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L50-L58). Der REST-Screener (cdb\_screener\_rest, Port 8080\) steht als Fallback für eine batchweise Top-Mover-Analyse zur Verfügung[\[2\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L46-L54). Beide Screener sind stateless und haben keine eigene Persistenz; sie dienen ausschließlich der *Datenerfassung* und Aufbereitung der Marktdaten.

## Funktionsweise des WS-Screener (Live-Feed)

Der WebSocket-Screener verbindet sich beim Start mit dem **MEXC WebSocket-Endpunkt** (wss://contract.mexc.com/ws)[\[8\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L10-L15), um kontinuierlich Kursdaten zu empfangen. Standardmäßig abonniert er 1-Minuten-Kerzen (*Interval* **Min1**) für sämtliche verfügbaren Symbole auf MEXC. Die Symbol-Liste kann dynamisch bezogen werden: Beim Start ruft der Screener einmalig alle Handelspaare über die MEXC-REST-API ab (/api/v1/contract/detail)[\[9\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L59-L67). Alternativ kann man die zu abonnierenden Symbole über die Umgebungsvariable SYMBOL\_WHITELIST manuell einschränken (kommagetrennte Liste) – ist diese Liste gesetzt, abonniert der Service nur diese Symbole[\[9\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L59-L67). Dies ist insbesondere sinnvoll, um die Datenmenge zu begrenzen, da MEXC maximal **200 Symbole pro WebSocket-Verbindung** erlaubt[\[10\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L4-L9). Überschreitet die Symbolanzahl diesen Wert, öffnet der Screener automatisch mehrere Verbindungen in **Chunks** à 200 Symbole, um alle gewünschten Märkte abzudecken[\[11\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L120-L128). Jede WebSocket-Verbindung wird in einem eigenen Thread betrieben und bei Verbindungsverlust mit exponentiellem Backoff neu aufgebaut[\[12\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L126-L134).

Sobald der WS-Screener **Tick-Daten** erhält, verarbeitet er sie wie folgt: Bei jedem eintreffenden Kline-Datensatz (1-Minuten-Candle) wird der Preis in einer In-Memory-Zeitschiebe gespeichert (Deque pro Symbol). Die Länge des Fensters richtet sich nach dem konfigurierten **Lookback** (Standard: 15 Minuten, über LOOKBACK\_MIN anpassbar)[\[13\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L16-L23). Aus dem ältesten und neuesten Preis im Fenster berechnet der Screener fortlaufend die prozentuale Kursänderung. Diese Informationen nutzt der Dienst für zwei Zwecke:

1. **Event-Publishing:** Der Screener erstellt aus jeder neuen Kerze ein **MarketData-Event** und publiziert es auf dem Redis-Pub/Sub-Kanal market\_data[\[14\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L98-L106). Ein Event enthält u.a. Symbol, Zeitpunkt, aktuellen Preis, Volumen und die prozentuale Änderung seit Fensterbeginn[\[14\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L98-L106). Nachgelagerte Dienste (z.B. die Signal-Engine) abonnieren diesen Kanal und erhalten so die Echtzeit-Marktdaten zur weiteren Verarbeitung[\[7\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L50-L58). Sollte Redis nicht verfügbar sein, fährt der Screener dennoch fort: Er loggt eine Warnung (“⚠ Redis nicht verfügbar”) und überspringt die Publizierung[\[15\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L30-L35), läuft aber lokal weiter. (Dadurch gehen Events zwar nicht an andere Services, aber der Screener bleibt aktiv – im MVP könnte in so einem Fall auch ein direkter In-Process-Transfer erfolgen, falls vorgesehen[\[16\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/ARCHITEKTUR.md#L12-L14).)

2. **Top-Mover-Berechnung:** Parallel zur Event-Publizierung ermittelt der Screener alle **15 Sekunden** (hartcodiert) die größten Gewinner und Verlierer im Betrachtungszeitraum. Hierzu berechnet er für jedes Symbol die prozentuale Veränderung vom ersten bis zum letzten Preis in der Deque und sortiert die Ergebnisse absteigend bzw. aufsteigend[\[17\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L141-L149). Die **Top 5 Gewinner** und **Top 5 Verlierer** werden sowohl im Log ausgegeben (alle 15s) als auch über einen einfachen HTTP-Endpoint bereitgestellt[\[18\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L155-L163)[\[19\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L44-L53). Der Flask-basierte Webserver des Screener bietet die Route **GET /top5** an, welche ein JSON mit Timestamp sowie Listen der Top-5-Gewinner und \-Verlierer zurückgibt[\[19\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L44-L53). Beispielausgabe (JSON): { ts: "2025-10-26 16:45:00 UTC", top5\_gainers: \[...\], top5\_losers: \[...\] }. Darüber hinaus stellt der Screener einen **Health-Check** unter **GET /health** zur Verfügung[\[20\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L37-L45). Dieser liefert den Status "ok", solange kürzlich (innerhalb \~60s) Daten empfangen wurden, bzw. "stale", falls der letzte Tick länger zurückliegt[\[21\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L38-L46). Zusätzlich werden die Anzahl beobachteter Symbole und die *age* (Sekunden seit letztem Tick) im Health-Response ausgegeben[\[21\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L38-L46). Docker und Monitoring-Dienste nutzen diesen Endpoint, um die **Gesundheit des Screener-Containers** zu überwachen[\[22\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/ARCHITEKTUR.md#L82-L90)[\[23\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/ARCHITEKTUR.md#L88-L92).

Zusammengefasst fungiert cdb\_screener\_ws als **Echtzeit-Datenquelle**: Er sammelt Live-Marktdaten via WebSocket, bereitet daraus interne Statistiken (Top-Mover) auf und verteilt die Daten als Events an die restliche Pipeline[\[7\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L50-L58). Durch die Kombination aus WebSocket-Feed und optionalem REST-Backup ist sichergestellt, dass sowohl kontinuierliche Streams als auch fallweise Momentaufnahmen der Marktbewegungen verfügbar sind.

## Einrichtung und Deployment (Server-Neuaufsetzung)

Falls der Server neu aufgesetzt werden muss, ist es wichtig, sämtliche Dienste in der richtigen Reihenfolge bereitzustellen und zu konfigurieren. Der WS-Screener selbst läuft als Docker-Container und kann entweder via **Docker Compose** oder manuell per Docker-Befehlen gestartet werden. Nachfolgend die Schritte, um das System (inklusive cdb\_screener\_ws) sauber neu zu deployen:

1. **Voraussetzungen & Konfiguration:** Stellen Sie sicher, dass Docker installiert und ausreichend Ressourcen (mind. 4 GB RAM) verfügbar sind[\[24\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Legen Sie eine Umgebungsdatei .env mit den nötigen Einstellungen an. Mindestens erforderlich sind die **MEXC API-Schlüssel** (MEXC\_API\_KEY und MEXC\_API\_SECRET), auch wenn der Screener für Marktdaten selbst keine Authentifizierung braucht – andere Komponenten (Execution) benötigen diese später[\[25\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Außerdem sollten Sie ein Passwort für die Postgres-DB definieren (POSTGRES\_PASSWORD) und – falls Redis abgesichert werden soll – ein REDIS\_PASSWORD festlegen. Die .env könnte z.B. so aussehen[\[25\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md)[\[26\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L14-L19):

MEXC\_API\_KEY=\<Ihr\_API\_Key\>  
MEXC\_API\_SECRET=\<Ihr\_API\_Secret\>  
POSTGRES\_USER=cdb\_user  
POSTGRES\_PASSWORD=\<Ihr\_DB\_Passwort\>  
REDIS\_PASSWORD=\<Ihr\_Redis\_Passwort\>  
SYMBOL\_WHITELIST=BTC\_USDT,ETH\_USDT    \# optional: nur diese Symbole tracken  
LOOKBACK\_MIN=15                      \# optional: Betrachtungszeitraum in Minuten

*Erläuterung:* Der Postgres-Benutzer und \-DB-Name werden in der Compose-Datei standardmäßig als cdb\_user und claire\_de\_binare gesetzt[\[27\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L32-L40). Redis läuft per Voreinstellung auf Port 6379 im Container, der nach außen auf Port 6380 gemappt ist[\[28\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L9-L17). Mit REDIS\_PASSWORD wird der Message-Bus abgesichert (Compose startet Redis mit requirepass)[\[26\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L14-L19) – dieser Wert muss von allen Services zum Publizieren/Abonnieren genutzt werden. Weitere optionale Umgebungsvariablen: MEXC\_BASE (Basis-URL der API, default *https://contract.mexc.com*), WS\_SCREENER\_PORT (falls Port 8000 kollidiert, anpassbar) und INTERVAL (für REST-Screener, default 1m). Die vorgabewerte aus der Architektur sind so gewählt, dass meist keine Änderung nötig ist[\[29\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/ARCHITEKTUR.md#L37-L45).

1. **Docker-Netzwerk und Datenbank starten:** Zuerst sollte das gemeinsame Docker-Netzwerk und die Persistenz-Infrastruktur hochgefahren werden. Bei Verwendung von Docker Compose genügt ein einzelner Befehl, um alle benötigten Container in der richtigen Reihenfolge zu starten. Beispiel mit Compose:

docker compose up \-d redis postgres 

Damit werden **Redis**, **Postgres** (und optional Monitoring wie Prometheus/Grafana) gestartet[\[30\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Prüfen Sie, ob die Kern-Infrastruktur läuft: docker compose ps sollte u.a. zeigen, dass cdb\_postgres und cdb\_redis den Status "Up (healthy)" haben[\[31\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). PostgreSQL führt beim ersten Start automatisch das bereitgestellte Schema (DATABASE\_SCHEMA.sql) aus und erstellt die nötigen Tabellen (insgesamt 9 Tabellen für Orders, Trades, Signals etc.)[\[32\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/GORDON_SETUP_GUIDE.md#L40-L48)[\[33\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/GORDON_SETUP_GUIDE.md#L90-L98). Vergewissern Sie sich, dass Postgres betriebsbereit ist (z.B. via docker exec cdb\_postgres pg\_isready \-U cdb\_user) – die Ausgabe sollte **"accepting connections"** melden[\[34\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/GORDON_SETUP_GUIDE.md#L84-L92). **Wichtig:** Die Anwendungs-Container sollten erst gestartet werden, *nachdem* die DB bereit ist[\[35\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SESSION_MEMO_REBUILD_2025-01-11.md#L121-L129), da z.B. die Signal-Engine beim Start ggf. DB-Zugriff braucht. (Compose depends\_on berücksichtigt den Container-Start, jedoch nicht, ob die DB intern fertig initialisiert ist. Warten Sie daher ein paar Sekunden nach Postgres-Start oder prüfen den Health-Status.)

1. **WS-Screener und weitere Services bauen & starten:** Jetzt können der Screener und die anderen Applikationsdienste hochgefahren werden. Mit Docker Compose erfolgt das durch Angabe der Servicenamen oder einfach aller auf einmal. Zum Beispiel:

docker compose up \-d bot\_ws bot\_rest signal\_engine risk\_manager

Beim ersten Mal werden die Docker-Images für die eigenen Services gebaut. Der WS-Screener wird aus dem Hauptprojektverzeichnis mit dem zentralen Dockerfile erstellt; über einen Build-Arg wird dabei das entsprechende Python-Skript (mexc\_top5\_ws.py) eingebunden[\[36\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L99-L107)[\[37\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L101-L109). Das Build dauert ca. 5 Minuten[\[38\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SESSION_MEMO_REBUILD_2025-01-11.md#L154-L162) und installiert alle benötigten Python-Abhängigkeiten (Requests, Pandas, Flask, WebSocket-Client, Redis-Py usw. sind in *requirements.txt* definiert[\[39\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/audits/DIFF-PLAN.md#L100-L108)). Analog werden die Images für Signal-Engine, Risk-Manager (und optional den REST-Screener) gebaut, was jeweils \~3 Minuten dauert[\[40\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SESSION_MEMO_REBUILD_2025-01-11.md#L160-L168). Compose erledigt diesen Build-Prozess automatisch beim ersten up. Ist alles erfolgreich, sollten schließlich alle Container laufen. Überprüfen Sie dies mit docker compose ps: neben Redis und Postgres sollten nun u.a. cdb\_ws (WebSocket Screener) und cdb\_rest (REST Screener) als **Up (healthy)** gelistet sein[\[31\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Insgesamt werden in der Minimal-Konfiguration etwa 4 Container kontinuierlich laufen (Postgres, Redis, WS-Screener, Signal, Risk) – im MVP ohne Execution-Service[\[41\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/GORDON_SETUP_GUIDE.md#L76-L84)[\[42\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/GORDON_SETUP_GUIDE.md#L116-L124).

*Hinweis:* In der Praxis kann man auch docker compose up \-d ohne Angabe nutzen, um *alle* definierten Services (inkl. Monitoring) zu starten[\[43\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Für eine Entwicklungs-/Testumgebung reicht es jedoch aus, zunächst nur die Kernkomponenten zu betreiben. Der REST-Screener (bot\_rest) ist optional; er wird in der Compose-Datei zwar mit gestartet, verbleibt aber im Leerlauf (führt alle 5 Minuten eine Top-Mover-Berechnung durch und beendet sich dann wieder im Loop)[\[44\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L134-L142). In der aktuellen Phase kann bot\_rest auch komplett deaktiviert werden, da bot\_ws die benötigten Daten liefert[\[45\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L48-L54). Wenn alle Dienste laufen, können Sie zur Kontrolle die Logs ansehen.

1. **Validierung & Gesundheit prüfen:** Nach dem Hochfahren sollten die wichtigsten **Health-Checks** durchgeführt werden, um sicherzustellen, dass das System einwandfrei läuft. Prüfen Sie z.B. die Health-Endpunkte der laufenden Services:

curl http://localhost:8000/health    \# WS-Screener  
curl http://localhost:8001/health    \# Signal-Engine  
curl http://localhost:8002/health    \# Risk-Manager

Für den **WS-Screener** (cdb\_ws) wird ein JSON mit "status":"ok" erwartet (bzw. "stale", falls noch keine oder seit \>60s keine Daten eingetroffen sind)[\[21\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L38-L46). Ein erfolgreicher Health-Check aller Services sollte in Docker Compose auch in der docker compose ps Übersicht sichtbar sein (STATUS "healthy")[\[31\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Zusätzlich kann man über curl http://localhost:8000/top5 die Top-5 Gewinner/Verlierer abfragen – direkt nach dem Start wird dieser Endpunkt vermutlich eine Fehlermeldung ("error": "no data yet") oder leere Felder liefern, da zunächst genügend Marktdaten gesammelt werden müssen. Nach ein paar Minuten Laufzeit sollte die Ausgabe jedoch gefüllt sein.

Ebenso wichtig ist ein Blick in die **Logs** aller Komponenten. Nutzen Sie docker compose logs \-f für alle Container oder gezielt docker compose logs \-f bot\_ws für den Screener[\[46\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Ein korrekt laufender WS-Screener zeigt Meldungen über verbundene WebSocket-Channels und regelmäßig aktualisierte Top-Mover-Listen im Log. Achten Sie darauf, **keine Fehler** zu sehen – insbesondere **Datenbank-Verbindungsfehler** oder **Redis-Errors** sollten nicht auftreten. Die letzten 20 Log-Zeilen können Sie z.B. so prüfen: docker logs \--tail 20 cdb\_ws[\[47\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/GORDON_SETUP_GUIDE.md#L104-L110). In einem fehlerfreien Betrieb dürfen dort keine ERROR\-Meldungen erscheinen[\[47\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/GORDON_SETUP_GUIDE.md#L104-L110). Wenn bis hierhin alles gesund ist ({"status":"ok"} von allen Services, Logs sauber, \~4–5 Container running), ist der Neuaufbau erfolgreich abgeschlossen[\[42\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/GORDON_SETUP_GUIDE.md#L116-L124).

## Fehlerbehebung und Optimierung

Trotz sorgfältiger Einrichtung können beim Betrieb des WS-Screeners oder beim Deployment Probleme auftreten. Hier sind häufige **Troubleshooting-Tipps** und mögliche Optimierungen, direkt aus der Projektdokumentation:

* **WebSocket verbindet sich ständig neu:** Falls im Screener-Log fortlaufend Meldungen wie *"WS Fehler \-\> reconnect"* auftauchen, deutet dies auf Verbindungsprobleme hin[\[48\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L3-L10). Häufige Ursachen sind: (1) Zu viele abonnierte Symbole (über 200 pro Verbindung, wodurch MEXC die Verbindung zurücksetzt)[\[10\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L4-L9), (2) Netzwerkprobleme oder Firewall blockiert WSS-Verkehr, oder (3) ungültige Symbolnamen. Lösungen: Stellen Sie sicher, dass der **Symbolumfang** das Limit von 200 nicht überschreitet – ggf. SYMBOL\_WHITELIST auf die wichtigsten Märkte begrenzen[\[49\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L40-L45). Testen Sie die WebSocket-Connectivity manuell, z.B. mit wscat (wscat \-c wss://contract.mexc.com/ws)[\[50\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L14-L19). Untersuchen Sie auch die Logs auf spezifische MEXC-Fehlercodes, um Hinweise zu erhalten[\[51\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L16-L20). Der Screener selbst splittet zwar die Subscription in 200er-Gruppen automatisch, aber ein sehr großes Universum an Symbols kann die Performance beeinträchtigen.

* **Hohe CPU-Last im Screener:** Beobachten Sie mit docker stats cdb\_ws die Ressourcennutzung. Eine anhaltende CPU-Auslastung von \>80% kann darauf hindeuten, dass zu viele Symbole gleichzeitig verarbeitet werden[\[52\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L38-L45). In diesem Fall ist es empfehlenswert, die zu überwachenden Märkte einzugrenzen (z.B. nur Top 50 Coins) über die Whitelist[\[49\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L40-L45). Weniger Streams bedeuten weniger JSON-Parsing und Berechnungen pro Sekunde und entlasten die CPU deutlich. Alternativ könnte man in Erwägung ziehen, den Screener horizontal zu skalieren (mehrere Instanzen aufgeteilt nach Märkten), was im MVP aber nicht vorgesehen ist.

* **Container startet nicht (CrashLoop)**: Wenn cdb\_screener\_ws gar nicht erst hochfährt oder sofort wieder stoppt, prüfen Sie die grundlegenden Einstellungen. Häufige Fehlerquellen sind falsche Zugangsdaten oder Port-Konflikte[\[53\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Vergewissern Sie sich, dass in .env die **API-Keys korrekt** eingetragen sind und keine ungültigen Zeichen enthalten[\[54\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Stellen Sie außerdem sicher, dass der Port **8000** auf dem Host nicht bereits von einem anderen Prozess belegt ist[\[55\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Sollte ein Build-Fehler die Ursache sein, führen Sie ein erneutes Build aus: docker compose build bot\_ws[\[56\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Auch ein Blick in docker compose logs bot\_ws zeigt meistens den Grund, falls etwa eine Python-Exception beim Start auftritt[\[57\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md).

* **Redis-Verbindung fehlgeschlagen:** Wenn der Screener im Log meldet, keine Verbindung zu Redis aufbauen zu können (oder im Health-Check des Risk/Signal-Service Redis-Fehler auftauchen), stellen Sie sicher, dass der Redis-Container läuft und erreichbar ist[\[58\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Testen können Sie dies z.B. mit docker exec cdb\_redis redis-cli \-a \<REDIS\_PASSWORD\> ping – die Antwort sollte **PONG** sein[\[59\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Bei Authentifizierungsproblemen überprüfen Sie, ob der REDIS\_PASSWORD in allen Services übereinstimmt. Im Notfall lässt sich der Screener auch ohne Redis betreiben, jedoch werden dann keine Events verteilt[\[15\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L30-L35).

* **Datenbankverbindung fehlgeschlagen:** Der WS-Screener selbst schreibt nicht in die Datenbank, aber andere Services (Signal, Risk) könnten Fehler loggen, falls die DB nicht erreichbar ist. In so einem Fall prüfen Sie docker compose logs postgres auf Meldungen wie "database system is ready to accept connections"[\[60\]](../ops/RUNBOOK_DOCKER_OPERATIONS.md). Warten Sie ggf. länger oder starten Sie abhängige Container neu (docker compose restart signal\_engine risk\_manager), sobald Postgres bereit ist.

* **Kein Top5-Output / keine Daten:** Unmittelbar nach dem Start kann es 1–2 Minuten dauern, bis genügend Kline-Daten für Berechnungen gesammelt wurden. Geduld ist hier wichtig – der Status wechselt von "stale" auf "ok"}, sobald die ersten Daten da sind[\[21\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L38-L46). Falls jedoch nach einiger Zeit immer noch "stale" bleibt, liegt vermutlich ein Problem mit dem Datenfeed vor (siehe oben: API-Key gesperrt? Symbol falsch? Netzwerkprobleme?). Prüfen Sie erneut die WebSocket-Verbindung und versuchen Sie testweise einen Neustart des Screener-Containers.

* **Not-Aus / Trading stoppen:** Sollte es notwendig sein, **sofort alle Handelsaktivitäten zu stoppen**, kann der WS-Screener (und damit der ganze Dateninput) pausiert oder beendet werden[\[61\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L47-L55). Ein docker pause cdb\_ws friert den Screener ein, ohne den Container zu terminieren[\[62\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L48-L51). Alternativ stoppt docker compose down alle Container vollständig[\[63\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/TROUBLESHOOTING.md#L48-L55). Dadurch werden keine neuen Signale oder Orders mehr generiert. (Für einen geordneten Neustart danach wieder docker compose up \-d bot\_ws signal\_engine risk\_manager ausführen.)

## Ausblick und mögliche Verbesserungen

Der **WS-Screener** ist in der aktuellen Architektur ein kritischer High-Priority-Service[\[64\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SESSION_MEMO_REBUILD_2025-01-11.md#L91-L99), da er die Grundlage für alle weiteren Module bildet. Die vorhandene Dokumentation wurde hier möglichst exakt zusammengefasst. Darüber hinaus ergeben sich ein paar sinnvolle Verbesserungsmöglichkeiten, die den Betrieb robuster machen könnten:

* **Backup-Strategie aktiv nutzen:** Derzeit ist der REST-Screener zwar implementiert, aber standardmäßig deaktiviert[\[65\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/SYSTEM_FLUSSDIAGRAMM.md#L18-L20). Es könnte erwogen werden, diesen als aktiven Fallback einzusetzen – z.B. dass er im Hintergrund alle 5 Minuten die Top-Mover berechnet und bei Ausfall des WebSocket-Feeds automatisch einspringt. So stünden zumindest periodisch aktualisierte Marktdaten zur Verfügung, selbst wenn der Live-Feed kurzzeitig unterbrochen ist.

* **Logging vereinheitlichen:** Laut Architekturvorgaben sollen alle Services ein einheitliches JSON-Logging nutzen[\[66\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/ARCHITEKTUR.md#L96-L101). Der Screener könnte dahingehend verbessert werden, indem er das bestehende logging\_config.json einliest und strukturierte Logs schreibt (anstatt derzeit ungeformatete Print-Statements). Dies würde die Überwachung und Analyse erleichtern, insbesondere wenn Logs von mehreren Services zusammengeführt werden.

* **Performance-Tuning:** Falls in Zukunft deutlich mehr Märkte beobachtet werden, sollte man die Skalierungsstrategie prüfen. Der Screener nutzt bereits mehrere Threads für Symbol-Chunks[\[11\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/mexc_top5_ws.py#L120-L128). Bei weiterer Last könnte man diese Architektur ausbauen (z.B. verteiltes Deployment auf mehrere Instanzen, um die Arbeit zu teilen). Auch die Nutzung eines effizienteren Datenstructures oder einer niedrigeren Tick-Frequenz (z.B. nur jede 5-Minuten-Kerze) wären Stellschrauben, um die Systemlast zu reduzieren – natürlich auf Kosten der Signal-Reaktionsgeschwindigkeit.

* **Erweiterungen laut Roadmap:** Laut System-Planung sind perspektivisch weitere Datenquellen und Services vorgesehen, etwa ein *ML-Advisor* oder News/Sentiment-Plugins[\[67\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/ARCHITEKTUR.md#L76-L79). Der Screener könnte modular erweitert werden, um neben reinen Kursdaten auch solche externen Indikatoren einzuspeisen. Für den Neuaufbau des Servers bedeutet das, zukünftige Dienste ähnlich wie den Screener zu integrieren (Docker-Service definieren, Event-Pipeline erweitern etc.), wobei die hier dokumentierten Grundlagen als Vorlage dienen können.

Zum Abschluss lässt sich festhalten, dass cdb\_screener\_ws als **Herzstück der Daten-Ingestion** fungiert und beim Neuaufsetzen des Systems besondere Beachtung verdient. Mit den obigen Informationen – von der Rolle im Gesamtbild, über Installation, bis zu Überwachung und Troubleshooting – ist sichergestellt, dass ein vollständiger Neuaufbau gelingt und der Marktdatenstrom zuverlässig läuft. Sobald der Screener “grünes Licht” gibt (Health-Status *ok* und keine Errors)[\[68\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/GORDON_SETUP_GUIDE.md#L98-L103), kann das übrige System darauf aufbauen und in Betrieb gehen. Damit ist der Weg frei für automatisierte Signalgebung, Risikoprüfung und letztlich Trading, basierend auf den Live-Daten, die der WS-Screener kontinuierlich liefert.

**Quellen:** Die obigen Inhalte wurden streng nach der vorhandenen Projektdokumentation zusammengestellt, insbesondere aus *ARCHITEKTUR.md*, *Docker-Setup Guides* und dem Code-Repository selbst. Alle Zitate und technischen Details stammen direkt aus den entsprechenden Dokumenten, um ein originales und zuverlässiges Nachschlagewerk für cdb\_screener\_ws zu bilden
