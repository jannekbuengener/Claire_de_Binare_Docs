---
status: archived
migration_status: resolved
note: "Legacy file-links entfernt, Textreferenzen beibehalten (ADR-027)"
---

# Signal Engine Microservice ‚Äì Technische Dokumentation

## Systemrolle & Architektur

Der **Signal Engine** Service fungiert als **strategische Handelssignalgenerierung** im deterministischen Handelssystem. Er empf√§ngt laufend **Marktdaten-Events** (Top-Mover Kursinformationen) vom WebSocket-Datenfeed-Service (z.B. *bot\_ws*) √ºber Redis und analysiert diese auf Momentum-Indikatoren[\[1\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/README.md#L12-L16). Konkret subscribt der Dienst das Redis Topic **market\_data** und pr√ºft f√ºr jedes eingehende Marktdaten-Event, ob eine bestimmte **prozentuale Preis√§nderungs-Schwelle** √ºberschritten wurde[\[2\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/README.md#L22-L29). Ist dies der Fall, erzeugt der Signal Engine daraus ein **Trading-Signal** (derzeit immer *BUY*) und publiziert es als Event auf dem **signals** Topic im Message-Bus[\[2\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/README.md#L22-L29). Die generierten Signale werden anschlie√üend vom nachgelagerten **Risk Manager** empfangen, der sie gegen mehrstufige Risikoregeln pr√ºft[\[3\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/README.md#L24-L29)[\[4\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/risk_manager/README.md#L16-L24). Wenn ein Signal alle Limits einh√§lt, leitet der Risk Manager es als **Order-Event** an den Execution-Service weiter; wird ein Limit verletzt, erzeugt er stattdessen ein **Alert-Event** zur Benachrichtigung[\[5\]][\[4\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/risk_manager/README.md#L16-L24).

Aus architektonischer Sicht ist der Signal Engine damit die zentrale **Strategie-Engine**: Er trennt die Datenerfassung von der Ausf√ºhrung, indem er aus Roh-Marktdaten deterministische Handelssignale ableitet[\[6\]]. Er ist in **Python** implementiert und l√§uft als eigenst√§ndiger Flask-basierten Microservice auf Port **8001**[\[7\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/README.md#L2-L6). Als zentrale Abh√§ngigkeit ben√∂tigt er einen **Redis** Message-Bus (zurzeit via Redis Pub/Sub) sowie einen laufenden Marktdatenfeed-Service (damit kontinuierlich Eingabedaten auf *market\_data* vorliegen)[\[7\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/README.md#L2-L6). Durch die lose Kopplung √ºber den Message-Bus ist der Signal Engine Service robust gegen√ºber Ausf√§llen anderer Komponenten: F√§llt er oder ein anderer Dienst aus, kann der jeweilige Service neu gestartet werden, ohne das Gesamtsystem zu destabilisieren[\[8\]].

## Eventschema & Datenfluss

**Eingangsdaten:** Der Signal Engine verarbeitet Events des Typs **market\_data**, welche √ºber das Redis Topic *market\_data* vom Datenfeed publiziert werden[\[1\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/README.md#L12-L16). Jedes Marktdaten-Event ist ein JSON-Objekt mit Feldern gem√§√ü dem globalen Event-Schema. Wichtige Felder sind u.a.:

* **symbol** (String, Handelspaar wie z.B. "BTC\_USDT", nur Gro√übuchstaben und Unterstrich erlaubt[\[9\]]),

* **price** (aktueller Preis, Zahl \> 0[\[10\]]),

* **volume** (gehandeltes Volumen im Intervall, Zahl ‚â• 0[\[10\]]),

* **pct\_change** (prozentuale Preis√§nderung im Intervall, Zahl ‚Äì typischerweise in Prozent, z.B. 4.5 f√ºr \+4,5%),

* **timestamp** (Unix-Zeitstempel, Integer) und

* **interval** (Intervall der Preis√§nderung, z.B. "15m", nur bestimmte Werte erlaubt[\[11\]]).

Ein vollst√§ndiges Marktdaten-Event besitzt au√üerdem den Feldwert *"type": "market\_data" zur Typkennzeichnung[\[12\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/models.py#L13-L20). Beispielhafte market\_data*\-Payloads aus dem Live-Feed k√∂nnten so aussehen (gek√ºrzt):

{  
  "type": "market\_data",  
  "symbol": "BTC\_USDT",  
  "price": 43000.12,  
  "volume": 150000.0,  
  "pct\_change": 4.5,  
  "timestamp": 1736555700,  
  "interval": "15m"  
}

**Verarbeitung:** Der Signal Engine ist als kontinuierliche Schleife umgesetzt, die auf neue Nachrichten auf *market\_data* wartet[\[13\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L160-L168). F√ºr jedes empfangene JSON-Event wird zun√§chst versucht, die Nutzlast in ein MarketData\-Objekt zu parsen. Dabei wird sichergestellt, dass alle erforderlichen Felder vorhanden sind und die Typen stimmen (durch die *dataclass* MarketData.from\_dict)[\[14\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/models.py#L21-L29). Im Anschluss wird die **Momentum-Strategie** angewendet: Es wird gepr√ºft, ob die prozentuale Preis√§nderung (pct\_change) den konfigurierten **Schwellenwert** √ºberschreitet[\[15\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L100-L108). Ist z.B. ein Kursanstieg ‚â• *3%* √ºber das letzte 15-Minuten-Intervall zu verzeichnen, und gleichzeitig das gehandelte Volumen im Intervall √ºber dem definierten **Mindestvolumen** liegt, generiert der Service ein neues Trading-Signal. Die folgende Pseudocode-Logik veranschaulicht den Entscheidungsprozess:

IF pct\_change \>= 3.0%:  
    IF volume \>= 100,000:  
        confidence \= min(pct\_change / 10.0, 1.0)  
        ‚Üí Generate BUY Signal  
        ‚Üí Publish to "signals" Topic  
\`\`\`„Äê33‚Ä†L110-L118„Äë

Im Erfolgsfall instanziiert der Service ein \`Signal\`-Objekt (Dataclass) mit allen relevanten Informationen: u.a. dem Symbol, \*\*Seite\*\* (\`"BUY"\` im Momentum-Fall), berechnetem \*\*Confidence-Score\*\* (zwischen 0.0 und 1.0 abh√§ngig von der St√§rke des Momentums) sowie einem Klartext-\*\*Grund\*\* f√ºr das Signal (z.B. \*"Momentum: \+4.5% (Schwelle: 3.0%)"\*)„Äê5‚Ä†L107-L115„Äë„Äê8‚Ä†L59-L63„Äë. Anschlie√üend wird dieses Signal als JSON serialisiert und auf das Redis Topic \*\*\`signals\`\*\* publiziert„Äê5‚Ä†L131-L139„Äë. Wenn die Kriterien nicht erf√ºllt sind (Preis√§nderung \< Schwelle oder Volumen zu gering), verwirft die Engine das Event stillschweigend (kein Signal)„Äê5‚Ä†L101-L108„Äë. 

\*\*Ausgangsdaten:\*\* Das publizierte Signal-Event hat den Typ \*\*\`signal\`\*\* und enth√§lt gem√§√ü \*EVENT\_SCHEMA\* mindestens folgende Felder: 

\- \*\*\`symbol\`\*\* (z.B. \`"BTC\_USDT"\`),   
\- \*\*\`side\`\*\* (\*BUY\* oder \*SELL\* ‚Äì aktuell generiert der Service nur BUY-Signale)„Äê11‚Ä†L21-L24„Äë,   
\- \*\*\`confidence\`\*\* (Gleitkommazahl zwischen 0 und 1 zur Angabe der Signalst√§rke„Äê11‚Ä†L21-L24„Äë),   
\- \*\*\`reason\`\*\* (Kurzbegr√ºndung, maximal 200 Zeichen„Äê11‚Ä†L22-L25„Äë, z.B. Momentum-Text) und   
\- \*\*\`timestamp\`\*\* (Erstellungszeitpunkt des Signals als Unix-Zeit). 

Auch hier dient \`"type": "signal"\` als Kennung„Äê8‚Ä†L34-L42„Äë. Ein beispielhaftes vom Signal Engine generiertes Event sieht so aus:

\`\`\`json  
{  
  "type": "signal",  
  "symbol": "BTC\_USDT",  
  "side": "BUY",  
  "confidence": 0.45,  
  "reason": "Momentum: \+4.5% (Schwelle: 3.0%)",  
  "timestamp": 1736556000,  
  "price": 43250.50,  
  "pct\_change": 4.5  
}  
\`\`\`„Äê33‚Ä†L126-L134„Äë

Dieses Signal wird asynchron √ºber Redis an alle Abonnenten des \*signals\*-Topics verteilt ‚Äì in erster Linie an den Risk Manager Service. Der \*\*Datenfluss\*\* vom Eingang bis zum Ausgang des Signal Engine l√§sst sich zusammenfassen als: 

bot\_ws (Datenfeed) ‚Üí Redis Topic "market\_data" ‚Üí Signal Engine ‚Üí Redis Topic "signals" ‚Üí Risk Manager \`\`\`[\[16\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L121-L129)

## Startup & Umgebung (ENV)

Der Service bezieht seine Konfiguration vollst√§ndig aus **Umgebungsvariablen**, was eine flexible Deployment-Konfiguration erm√∂glicht. Beim Start werden alle erforderlichen ENV-Variablen eingelesen und validiert[\[17\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L59-L67)[\[18\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/config.py#L33-L40). Die wichtigsten Einstellungen sind:

* **SIGNAL\_PORT** ‚Äì Port, auf dem der interne Flask-Webserver l√§uft (Default **8001**)[\[19\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/config.py#L14-L17).

* **REDIS\_HOST** / **REDIS\_PORT** ‚Äì Hostname und Port des Redis-Servers (Default **"redis"** im Docker-Netzwerk bzw. **6379** als Port)[\[20\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/config.py#L18-L21). In Docker-Compose ist REDIS\_HOST typischerweise auf den Service-Namen *redis* gesetzt.

* **REDIS\_PASSWORD** ‚Äì Passwort f√ºr Redis (optional; wird genutzt, falls der Redis-Server Authentifizierung erfordert). Im Compose-Setup ist ein Passwort Pflicht und wird √ºber .env bereitgestellt, der Signal Engine liest dieses aus und authentifiziert sich damit[\[21\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L70-L78). Ist kein Passwort gesetzt, versucht der Service ohne Auth zu verbinden ‚Äì bei einem gesch√ºtzten Redis f√ºhrt dies zu einem Verbindungsfehler und Beenden des Dienstes[\[22\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L86-L88).

* **REDIS\_DB** ‚Äì Redis-Datenbank-Index (Default **0**)[\[23\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/config.py#L18-L22).

* **SIGNAL\_THRESHOLD\_PCT** ‚Äì Schwellwert der prozentualen Preis√§nderung f√ºr Signalgenerierung (Default **3.0** %)[\[24\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/config.py#L24-L27).

* **SIGNAL\_LOOKBACK\_MIN** ‚Äì Betrachtungszeitraum in Minuten f√ºr die Preis√§nderung (Default **15** Minuten)[\[24\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/config.py#L24-L27). Dieser Wert dient informativ der Strategie, in der aktuellen Implementierung wird der Intervallwert aber aus den Marktdaten √ºbernommen (Standard 15m).

* **SIGNAL\_MIN\_VOLUME** ‚Äì Minimales Handelsvolumen im Intervall, damit ein Signal generiert wird (Default **100000**)[\[25\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/config.py#L24-L28). Dies filtert illiquide M√§rkte aus.

* **ENV** ‚Äì Betriebsumgebung (Default **"development"**). Diese Variable kann auf "production" gesetzt werden, um z.B. Logging-Level oder andere Verhaltensweisen in einer Produktionsumgebung zu steuern.

Alle obigen Variablen sind im Docker-Setup in einer zentralen *.env*\-Datei definiert und werden beim Containerstart injiziert[\[26\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L106-L114)[\[27\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/config.py#L14-L22). Fehlen kritische Einstellungen, verwendet der Service sichere **Default-Werte**, sodass er auch ohne explizite .env-Eintr√§ge lauff√§hig ist. Einige Parameter werden jedoch gepr√ºft: So validiert die Methode config.validate() beim Start, dass die Schwellenwerte sinnvoll sind ‚Äì z.B. muss SIGNAL\_THRESHOLD\_PCT \> 0 und SIGNAL\_LOOKBACK\_MIN \> 0 sein, andernfalls bricht der Start mit einer klaren Fehlermeldung ab[\[28\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/config.py#L34-L42). Dies stellt sicher, dass keine ung√ºltigen Konfigurationen (etwa ein Schwellenwert von 0%) in Produktion gelangen.

**Sicherheitsaspekte:** Sensible Zugangsdaten (wie das Redis-Passwort) werden nicht im Code hinterlegt, sondern ausschlie√ülich √ºber Umgebungsvariablen bezogen. Der Service loggt diese nicht im Klartext, und durch Verwendung der env-Datei bleiben Secrets vom Quellcode getrennt. Bei √Ñnderungen der Schwellwerte oder Limits kann die .env-Datei angepasst und der Dienst neu gestartet werden, ohne Code√§nderungen vorzunehmen[\[29\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L156-L164). Zudem l√§uft der Flask-Server standardm√§√üig auf localhost (0.0.0.0 innerhalb des Containers) auf dem definierten Port und ist in der Compose-Datei nur nach Bedarf nach au√üen gemappt ‚Äì im Regelfall ist er nur innerhalb des Docker-Netzwerks erreichbar (oder lokal auf dem Host, falls explizit freigegeben)[\[30\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L13-L20)[\[31\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L53-L61).

## Logging & Monitoring

Der Signal Engine implementiert **strukturiertes Logging** und bereitgestellt Monitoring-Schnittstellen, um den Betrieb nachvollziehbar und √ºberwachbar zu machen. Beim Initialisieren wird versucht, eine zentrale Logging-Konfiguration aus logging\_config.json zu laden[\[32\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L22-L30). Ist diese Datei vorhanden (global f√ºr das Projekt definiert), werden dar√ºber Format und Ausgabe der Logeintr√§ge gesteuert ‚Äì typischerweise im JSON-Format f√ºr eine einfachere Weiterverarbeitung[\[33\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L44-L48). Falls die Datei nicht verf√ºgbar ist, f√§llt der Service auf ein Standard-Logging zur√ºck (basicConfig), das Logs mit Zeitstempel, Log-Level und Message auf stdout schreibt[\[34\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L28-L34). In beiden F√§llen schreibt der Logger unter dem Namenspr√§fix "signal\_engine" auf **INFO-Level** alle wichtigen Ereignisse, sowie **DEBUG**\-Nachrichten f√ºr detailliertere Diagnosen (z.B. falls ein Event wegen zu geringem Volumen ignoriert wird)[\[35\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L101-L109). Wichtige Vorg√§nge wie erfolgreiche Konfiguration, Verbinden zu Redis, Start der Hauptschleife sowie jedes generierte Signal werden mindestens als Info-Log festgehalten[\[36\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L76-L84)[\[37\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L120-L128). Fehlerf√§lle (z.B. JSON-Parsing-Probleme oder Redis-Ausf√§lle) werden als **WARNING** oder **ERROR** geloggt, inklusive eines Stacktraces falls n√∂tig[\[38\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L176-L184). Nach dem Start sollte im Log etwa Folgendes erscheinen:

\[INFO\] signal\_engine: Config validiert ‚úì \[INFO\] signal\_engine: Redis verbunden: redis:6379 \[INFO\] signal\_engine: Subscribed zu Topic: market\_data \[INFO\] signal\_engine: üöÄ Signal-Engine gestartet[\[39\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L78-L84)

F√ºr das **Monitoring** stellt der Service drei HTTP-Endpoints zur Verf√ºgung, die vom internen Flask-App bereitgestellt werden[\[40\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L202-L210)[\[41\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L216-L225):

* **GET /health** ‚Äì einfacher Health-Check, der den Status des Services zur√ºckgibt. Solange der Service l√§uft und die Hauptschleife aktiv ist, antwortet dieser Endpoint mit {"status":"ok","service":"signal\_engine","version":"0.1.0"} und HTTP 200[\[42\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L202-L209). Ist der Dienst gestoppt oder h√§ngt, w√ºrde "status":"error" zur√ºckkommen (die Health-Checks der Orchestrierung erkennen dies und markieren den Container als unhealthy)[\[42\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L202-L209).

* **GET /status** ‚Äì liefert detaillierte **Status- und Statistikdaten** des Services als JSON. Dazu geh√∂ren Startzeit (started\_at), die Anzahl generierter Signale (signals\_generated), Details zum letzten Signal (last\_signal) und der aktuelle Status ("running" oder "stopped")[\[43\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L138-L146)[\[44\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L210-L215). Dieses Endpoint dient prim√§r zur Diagnose oder f√ºr ein Dashboard.

* **GET /metrics** ‚Äì gibt **Prometheus-kompatible Metriken** im Klartext zur√ºck[\[41\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L216-L225). Insbesondere werden Metriken wie signals\_generated\_total (Counter f√ºr die Gesamtzahl der erzeugten Signale) und signal\_engine\_status (Gauge mit Wert 1 wenn laufend, 0 wenn gestoppt) exportiert[\[45\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L218-L225). Diese Metriken k√∂nnen vom zentralen Prometheus-Scraper abgeholt werden.

Der Signal Engine ist bereits in das zentrale **Monitoring-Setup** integriert. In der *prometheus.yml* ist ein Scrape-Job f√ºr signal\_engine konfiguriert, der alle 15s den Endpoint signal\_engine:8001/metrics abfragt[\[46\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/prometheus.yml#L22-L30). Dadurch sind die Kenndaten des Services (Anzahl Signale, Alive-Status etc.) im Zeitverlauf beobachtbar. Der Docker-Compose definiert au√üerdem einen Healthcheck, der periodisch http://localhost:8001/health aufruft, um den Container-Status zu pr√ºfen[\[47\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L180-L188). In Grafana k√∂nnen die Metriken visualisiert werden (z.B. Signalrate, keine neuen Signale als Warnzeichen etc.), und bei Ausbleiben von "signals\_generated" oder einem Ausfall k√∂nnen konfigurierbare **Alerts** ausgel√∂st werden.

Zusammenfassend ist der Service √ºber Logs und Metriken gut introspektierbar: Er nutzt **JSON-f√§higes Logging**, das konsistent mit anderen Diensten formatiert ist, und bietet dedizierte **Health/Metrics** Endpoints f√ºr automatisiertes Monitoring[\[33\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L44-L48)[\[48\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L36-L39).

## Dockerisierung

Die Bereitstellung des Signal Engine erfolgt in einem isolierten Docker-Container, der nach Microservice-Prinzip minimal und sicher konfiguriert ist. Der **Dockerfile** befindet sich im Verzeichnis des Services[\[49\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L13-L21) und basiert auf einem schlanken Python-Basisimage (z.B. python:3.11-slim). Beim Build werden zun√§chst die Python-**Abh√§ngigkeiten** (siehe requirements.txt) installiert und anschlie√üend der Service-Code ins Image kopiert. Der Container l√§uft nicht als Root, sondern ein dedizierter Benutzer (UID 1000, z.B. *botuser*) wird erstellt und f√ºr den App-Lauf genutzt ‚Äì dies erh√∂ht die Sicherheit, da im Falle einer Kompromittierung des Prozesses keine Root-Rechte vorliegen[\[50\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/Dockerfile#L28-L36).

Der **Startbefehl** des Containers ist so definiert, dass direkt der Signal Engine gestartet wird (Entry-point/CMD ruft python \-u service.py auf). Dadurch initialisiert sich der Flask-Webserver und die Signal-Engine-Hauptschleife automatisch beim Container-Start. Im Docker-Compose ist der Service folgenderma√üen eingebunden:

yaml signal\_engine: build: context: ./backoffice/services/signal\_engine container\_name: cdb\_signal ports: \- "8001:8001" env\_file: .env depends\_on: \- redis \- bot\_ws volumes: \- signal\_data:/data healthcheck: test: \["CMD", "curl", "-fsS", "http://localhost:8001/health"\] interval: 30s timeout: 3s retries: 3 security\_opt: \- no-new-privileges:true cap\_drop: \- ALL read\_only: true networks: \- cdb\_network[\[51\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L166-L175)[\[52\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L182-L190)

Wie oben ersichtlich, wird Port **8001** im Container nach au√üen exponiert (f√ºr Health/Metrics). Der Service ist abh√§ngig von **Redis** (Message-Bus) und **bot\_ws** (Marktdatenfeed) ‚Äì Docker sorgt daf√ºr, dass diese Container vorg√§ngig gestartet werden[\[53\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L178-L186). Der Mount eines **persistent Volume** auf /data (**signal\_data**) ist vorgesehen, um etwaige lokale Daten oder Logs dauerhaft zu speichern[\[54\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L174-L182). Aktuell nutzt der Signal Engine dieses Volume noch nicht aktiv f√ºr die Signalverarbeitung (State ist vornehmlich in Redis), aber es kann f√ºr zuk√ºnftige Erweiterungen (z.B. Caching oder lokale Checkpoints) oder Logpersistenz eingesetzt werden. In Entwicklungsumgebungen kann alternativ der Quellcode als Volume eingeh√§ngt werden, um Live-Code-Reload zu erm√∂glichen; standardm√§√üig ist das Dateisystem im Container jedoch **read-only** geschaltet (au√üer definierter Schreibpfade wie /data oder tempor√§r /tmp)[\[55\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L186-L194). Dies erh√∂ht die Sicherheit, da der Service zur Laufzeit keine unvorhergesehenen √Ñnderungen am Image-Dateisystem vornehmen kann. Zus√§tzlich werden im Compose alle Linux **Capabilities gedroppt** und das Flag *no-new-privileges* gesetzt, um das Angriffspotential weiter zu minimieren[\[55\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L186-L194).

Die Container-Isolierung und \-Absicherung sorgt daf√ºr, dass der Signal Engine im Betrieb m√∂glichst wenig Angriffsfl√§che bietet. Das **Netzwerk** *cdb\_network* verbindet ihn intern mit Redis und den anderen Diensten[\[56\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L190-L194). Extern ist ‚Äì je nach Compose-Einstellung ‚Äì der Port 8001 zug√§nglich, was prim√§r f√ºr lokale Tests gedacht ist (Produktiv k√∂nnte man den Port unexposed lassen, da Monitoring auch innerhalb des Netzwerks erfolgen kann). Der typische Workflow zum (Re-)Deploy des Containers ist in der Projekt-Doku festgehalten, z.B.: Image bauen mit docker compose build signal\_engine und starten mit docker compose up \-d signal\_engine[\[57\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L92-L100). Durch den definierten Healthcheck wird der laufende Container kontinuierlich √ºberwacht; sollte der Prozess innerhalb ausfallen, markiert Docker ihn als unhealthy und ein Restart-Policy (restart: unless-stopped) sorgt f√ºr automatischen Neustart[\[58\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L10-L18)[\[59\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docker-compose.yml#L170-L178).

## Recovery & Wiederaufbau

Da der Signal Engine Service **zustandslos** arbeitet (keine persistente eigene Datenbank, State nur in Form der zuletzt empfangenen Events und interner Z√§hler), ist ein Recovery im Fehlerfall unkompliziert. Wenn der Container abst√ºrzt oder versehentlich gel√∂scht wird, kann er **einfach neu gestartet** oder neu erstellt werden, ohne dass historische Daten wiederhergestellt werden m√ºssen. Konkret empfiehlt es sich, im Fehlerfall zun√§chst die **Logs zu pr√ºfen** (docker compose logs signal\_engine oder docker logs cdb\_signal)[\[60\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L170-L177), um die Ursache einzugrenzen ‚Äì h√§ufige Probleme sind z.B. *Redis nicht erreichbar* (dann muss der Redis-Server neu gestartet oder die Verbindungseinstellungen gepr√ºft werden)[\[61\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L174-L177), ein belegter Port 8001 auf dem Host (anderer Prozess blockiert den Port)[\[62\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L173-L177) oder fehlende ENV-Variablen (dann .env erg√§nzen)[\[61\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L174-L177). Diese Probleme lassen sich meist durch Anpassen der Umgebung und anschlie√üenden Neustart l√∂sen.

**Wiederherstellungsschritte:** Sollte der Service gestoppt sein, startet man ihn neu via Docker Compose (docker compose up \-d signal\_engine). Compose k√ºmmert sich darum, dass Abh√§ngigkeiten wie Redis vorhanden sind ‚Äì sollte Redis selbst ausgefallen sein, ist dessen Neustart Voraussetzung, da der Signal Engine sich beim Start sofort mit Redis verbindet (ein fehlender Redis f√ºhrt beim Start zu einem Exit)[\[22\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/service.py#L86-L88). Nach dem (Wieder-)Start sollte gepr√ºft werden, ob der Service ordnungsgem√§√ü l√§uft: Der Health-Endpoint (curl http://localhost:8001/health) sollte Status **"ok"** zur√ºckmelden[\[63\]], und im Log sollten Meldungen wie *"Redis verbunden: ...", "Subscribed zu Topic: market\_data", "Signal-Engine gestartet"* erscheinen[\[64\]]. Auch im Redis selbst kann man mittels redis-cli MONITOR beobachten, ob wieder **Events flie√üen** ‚Äì man sollte innerhalb kurzer Zeit Publish-Eintr√§ge auf *market\_data* und *signals* sehen (z.B. PUBLISH "market\_data" {...} gefolgt von PUBLISH "signals" {...})[\[65\]].

Weil der Dienst keinen eigenen persistenten Zustand hat, beschr√§nkt sich ein "Recovery" im Wesentlichen darauf sicherzustellen, dass die **Eingangsdaten** wieder verf√ºgbar sind und der Service ordnungsgem√§√ü subscribt. Laufende Handelslogik wird durch einen Neustart nicht inkonsistent ‚Äì allerdings gehen m√∂glicherweise *kurz vor dem Absturz generierte Signale* verloren, da Redis Pub/Sub keine Warteschlange im Auslieferungszustand hat. Sollte also der Signal Engine vor√ºbergehend ausfallen, werden w√§hrenddessen eintreffende Marktdaten nicht in Signale umgewandelt. Nach dem Neustart werden nur neue Events ab diesem Zeitpunkt verarbeitet. In einem solchen Fall ist es ratsam, einen schnellen manuellen Check zu machen, ob kurz vor dem Ausfall eventuell ein starkes Marktsignal unbehandelt blieb. Ansonsten stellt der Risk Manager sicher, dass keine veralteten Signale zu Orders f√ºhren ‚Äì er pr√ºft z.B. Zeitstempel und kann versp√§tete Signale ignorieren (Projektvision sieht deterministische, zeitnahe Verarbeitung vor).

**Abh√§ngigkeiten:** F√ºr einen erfolgreichen Wiederanlauf des Signal Engine m√ºssen **Redis** und der **Marktdatenfeed** laufen. Ist der Datenfeed (z.B. *bot\_ws*) noch nicht aktiv, startet zwar der Signal Engine (Health ist ok), aber es kommen keine neuen *market\_data*\-Events ‚Äì folglich werden auch keine Signale generiert. Dies erkennt man daran, dass signals\_generated im Status und in den Metriken gleichbleibt. In solch einem Fall hilft ein Blick in die Screener-Logs (docker logs cdb\_ws), ob Marktdaten publiziert werden[\[66\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L180-L188). Wenn nein, muss der Feed-Service neu gestartet werden. Sobald alle Dependencies laufen, arbeitet der Signal Engine deterministisch seinen Job ab. Die **Erfolgskontrolle** nach Recovery besteht also darin, die Health/Metrics zu pr√ºfen und sicherzustellen, dass neue *market\_data*\-Ereignisse auch tats√§chlich wieder *signal*\-Events nach sich ziehen (z.B. via Redis-Subscribe oder im Grafana-Dashboard auf die Metrik *signals\_generated\_total* achten).

Sollte der Container-Image selbst korrupt sein (seltener Fall, z.B. durch Festplattenfehler), kann man das Image neu bauen (docker compose build signal\_engine oder das bereitgestellte Build-Skript) und den Container neu aufsetzen[\[67\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/scripts/build_all_images.ps1#L14-L22). Da der Code im Repository versioniert ist, l√§sst sich so immer eine konsistente Version herstellen. Insgesamt folgt der Service dem Prinzip **"stateless and disposable"** ‚Äì im Fehlerfall neu starten oder neu deployen, anstatt manuell Zustand reparieren zu m√ºssen.

## Testing & E2E-Integration

Die korrekte Funktion des Signal Engine Services wird durch verschiedene Testans√§tze sichergestellt, von Komponententests bis zur End-to-End-Pr√ºfung im laufenden System.

**Komponententests & Logik-Pr√ºfung:** Aufgrund der deterministischen, regelbasierten Natur der Momentum-Logik l√§sst sich diese gut mit **Unit Tests** validieren. Beispielsweise kann man der process\_market\_data\-Methode gezielt simulierte Marktdaten-Events √ºbergeben (etwa mit unterschiedlichen pct\_change und volume Werten) und √ºberpr√ºfen, ob ein Signal erzeugt wird oder nicht. Ein positiver Testfall w√§re z.B. ein Event mit pct\_change \= 5.0 und hohem Volumen, bei dem erwartet wird, dass ein Signal mit confidence \= 0.5 zur√ºckkommt, w√§hrend ein Event mit pct\_change \= 1.0 (unter Schwelle) **kein** Signal liefern sollte. Solche Logiktests sind im Code durch die klare Trennung in MarketData\- und Signal\-Modelle sowie die isolierte Methode process\_market\_data einfach durchzuf√ºhren. Derzeit liegen prim√§r manuelle Tests vor (der Entwickler testete lokal mit k√ºnstlichen Daten und √ºberwachte die Logs), automatisierte Unit-Testskripte k√∂nnen aber nach dem MVP-Stadium noch erg√§nzt werden.

**Integrationstests:** Die Zusammenspiel mit anderen Services wurde mittels definierter Testabl√§ufe gepr√ºft. In der Dokumentation ist ein **End-to-End-Test** skizziert, der den gesamten Datenfluss vom Marktdateneingang bis zur Order-Verarbeitung abdeckt[\[68\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L222-L228). In dieser Testprozedur werden alle relevanten Container (Redis, bot\_ws, signal\_engine, risk\_manager, etc.) gestartet[\[69\]]. Anschlie√üend beobachtet man die Systemreaktionen √ºber ca. 30 Minuten. Wichtige Pr√ºfpunkte sind:

* **Logs:** In den Logs aller Container sollten keine Fehler erscheinen. Insbesondere im cdb\_signal Log wird erwartet: *"Redis verbunden..."*, *"Signal-Engine gestartet..."*, und bei entsprechenden Marktbewegungen Meldungen √ºber generierte Signale[\[64\]]. Im cdb\_risk Log sollte ein Subscribe auf *signals* und ggf. Freigaben/Blockaden von Orders zu sehen sein[\[70\]].

* **Health-Checks:** Die /health Endpoints von Signal Engine und Risk Manager geben Status 200/ok zur√ºck[\[63\]]. Die Docker-Compose UI (oder docker compose ps) zeigt beide Container als healthy[\[71\]].

* **Redis Event-Fluss:** Mit redis-cli MONITOR beobachtet man live die Events. Innerhalb von 1-2¬†Minuten sollten Eintr√§ge wie PUBLISH "market\_data" {...} und darauf folgend PUBLISH "signals" {...} auftauchen[\[65\]]. Dies best√§tigt, dass der Signalpfad funktioniert. Im Idealfall sieht man auch PUBLISH "orders" {...} Events, sofern der Risk Manager Signale freigibt[\[72\]].

* **Persistenzpr√ºfung:** In der aktuellen Systemversion werden generierte Signale und Orders in der PostgreSQL-Datenbank mitprotokolliert. Ein Integrationstest beinhaltet daher, nach einigen Minuten Laufzeit SQL-Queries auf die Datenbank auszuf√ºhren (z.B. SELECT COUNT(\*) FROM signals;), um sicherzustellen, dass Signale aufgezeichnet wurden[\[73\]]. In einem vollst√§ndigen Testaufbau wurde verifiziert, dass nach \~2-3¬†Minuten **mehrere Signale** in der DB stehen (bei aktiven Marktbewegungen)[\[74\]]. Ebenso kann man pr√ºfen, ob entsprechende Order-Eintr√§ge vorhanden sind, falls Trades ausgef√ºhrt wurden.

**Ablauf vom Marktdaten-Event bis Order/Alert:** Im Gesamtsystem wurde getestet, dass die Kette der Services erwartungsgem√§√ü reagiert. Sobald der Signal Engine ein neues *market\_data*\-Ereignis mit gen√ºgend Momentum erh√§lt, publiziert er umgehend ein Signal-Event[\[75\]]. Der Risk Manager, der auf *signals* subscribt, registriert dieses Signal in wenigen Millisekunden und f√ºhrt seine Risiko-Pr√ºfungen durch[\[5\]]. Je nach Ergebnis passiert folgendes: **(a)** Das Signal wird **freigegeben** ‚Äì der Risk Manager erstellt daraus ein Order-Event (inkl. berechneter Ordergr√∂√üe und Stop-Loss gem√§√ü seinen Parametern) und publiziert dieses auf dem *orders*\-Channel[\[76\]]. Der Execution-Service empf√§ngt das Order-Event und f√ºhrt den Trade an der Exchange aus. **(b)** Das Signal wird **blockiert** ‚Äì der Risk Manager verwirft das Signal und erzeugt ein Alert-Event auf dem *alerts*\-Channel, welches z.B. den Grund der Ablehnung (Risk-Limit √ºberschritten etc.) enth√§lt[\[77\]]. Ein Benachrichtigungs-Service kann solche Alerts aufgreifen, um den Betreiber zu informieren (z.B. via E-Mail oder UI-Indikator). Beide F√§lle wurden im Test simuliert, indem k√ºnstlich Signale erzeugt wurden, die einmal innerhalb der Limits lagen und einmal ein Limit rissen. Das System reagierte deterministisch: erlaubte Signale f√ºhrten zu entsprechenden **Order-Auftr√§gen**, abgelehnte zu **Warnmeldungen**, ohne Seiteneffekte auf andere Komponenten. Dieses Verhalten stimmt mit der in der Architektur vorgegebenen Sequenz √ºberein[\[5\]] und validiert die korrekte Integration.

Zuletzt wurde ein l√§ngerer **Stabilit√§tstest (Paper-Trading √ºber 7 Tage)** durchgef√ºhrt, bei dem der Signal Engine kontinuierlich lief und echte Marktdaten verarbeitete[\[78\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/7D_PAPER_TRADING_TEST.md#L9-L17). In diesem Zeitraum traten keine Speicherlecks oder Abst√ºrze auf, die **Metriken blieben stabil** (konstante Signalrate in ruhigen Marktphasen, Peaks bei Volatilit√§t erkennbar), und die **Logging**\-Volumes f√ºllten sich moderat mit erwarteten Infos. Alerts wurden nur in sinnvollen Situationen ausgel√∂st (z.B. simulierte √úberschreiten des Tagesverlustlimits im Risk Manager) ‚Äì ein Hinweis auf die robuste Implementierung der ganzen Pipeline.

**Zusammenfassung:** Der Signal Engine wurde sowohl isoliert (Unit-Tests der Logik, lokale Runs) als auch im Verbund mit den angrenzenden Services getestet. Durch Health-Checks, Metrics und die Entkopplung √ºber den Message-Bus l√§sst er sich leicht in automatisierte Integrationstests einbeziehen. Die End-to-End-Tests best√§tigen, dass vom eintreffenden Marktdaten-Event bis hin zur ausgehenden Order oder Alert alles wie vorgesehen flie√üt[\[6\]][\[79\]]. Damit erf√ºllt der Signal Engine verl√§sslich seine Rolle als deterministischer Signalgeber im Gesamtsystem.

**Quellen:** Die obigen Informationen wurden projektspezifisch aus der Claire de Binare Codebasis und Dokumentation entnommen, insbesondere den Modulen des signal\_engine Services (Code und README) sowie den globalen Architektur- und Testdokumenten[\[80\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/backoffice/services/signal_engine/README.md#L12-L20)[\[6\]][\[81\]](https://github.com/jannekbuengener/Claire-de-Binare/blob/4ccbfbb4d2b69d8d0bdef6128dcf5c0df701a955/docs/reports/SIGNAL_ENGINE_COMPLETE.md#L126-L134). This ensures that the documentation remains consistent with the actual implementation and system design.

---

